This repository contains the code for the Motor\+Controller board, developped by Telecom Robotics. This board is part of the \href{https://github.com/TelecomParistoc/robot-framework}{\tt robot-\/framework} currently developped by the association. It can also be used independantly from this framework. This board, and the associated code, are in charge of handling all low-\/level tasks related to robot moves\+: motor control, data acquisition from various sensors (I\+MU and coding wheels for now), current position computation and so on.

Below, you\textquotesingle{}ll find the documentation for the various components of this project.

\section*{Download}

In order to get a working copy of this code, you have to follow some steps in addition to simply clone this repo. Indeed, some generic drivers (the I\+MU driver for now) are included as a submodule. The interest of submodules is that they allow you to always get the most up-\/to-\/date version of a project developped in an independant repository. And keeping repository focused on a single project appears to us as a good practice\+: one repository for one project.

Run the following commands in a terminal to get a fully usable copy of this project\+:
\begin{DoxyItemize}
\item clone the repository
\item cd in the directory of the repo
\item {\ttfamily \$ git submodule init}
\item {\ttfamily \$ git submodule update}
\end{DoxyItemize}

At any time when using this repo, if you want to obtain the latest updates of the generic drivers, you can use {\ttfamily \$ git submodule update -\/-\/remote}.

\section*{Compilation \& flash}

The same code is used for both robots. Data which are specific to each robot (P\+ID coeffs, motor configuration, ...) are stored in flash and loaded when the program starts. Simply run {\ttfamily \$ make} to compile the code. List of {\itshape make} targets available\+:
\begin{DoxyItemize}
\item {\bfseries all}\+: compile the code
\item {\bfseries clean}\+: delete all files produced by the compilation process
\item {\bfseries debugserver}\+: launch J\+Link\+G\+D\+B\+Server and waits for a G\+DB connection
\item {\bfseries gdb}\+: start gdb with the binary file of the project
\end{DoxyItemize}

To flash a board, follow these steps\+:
\begin{DoxyItemize}
\item connect the S\+E\+G\+G\+ER probe to the board with the S\+WD cable and to your computer with the U\+SB cable.
\item power up the board
\item go the parent directory of this repository (the one containing the Makefile)
\item run {\ttfamily \$ make} in a terminal
\item run {\ttfamily \$ make debugserver}
\item open a new terminal
\item run {\ttfamily \$ make gdb} in this new terminal
\end{DoxyItemize}

To see the printf output, you need J\+Link\+R\+T\+T\+Client. You should already have it (it comes with J\+Link\+G\+D\+B\+Server). In another terminal, run {\ttfamily \$ J\+Link\+R\+T\+T\+Client}.

Note\+: If you don\textquotesingle{}t have J\+Link\+G\+D\+B\+Server, you can download it \href{https://www.segger.com/downloads/jlink-beta/}{\tt here} (choose {\itshape J-\/\+Link Software and Documentation Pack}).

\section*{Description}

The picture below shows the general architecture of this software component\+: 

This project uses Chibi\+OS as its operating system. For a complete description of this OS, go the dedicated \href{http://www.chibios.org/dokuwiki/doku.php}{\tt website}.

\subsection*{Communication}

This component is in charge of the communication between the central unit of the robot (a Raspberry Pi in the actual implementation) and the motorboard. It acts as an I2C slave, providing an interface that looks like memory-\/mapped registers. For the descriptions of this interface, see the file ./specs.md \char`\"{}specs.\+md\char`\"{}.

It\textquotesingle{}s composed of 2 files\+:
\begin{DoxyItemize}
\item {\itshape \hyperlink{i2c__interface_8h_source}{i2c\+\_\+interface.\+h}}
\item {\itshape i2c\+\_\+interface.\+c}
\end{DoxyItemize}

\subsection*{Coding wheels}

This component is responsible of handling the coding wheels inputs. It\textquotesingle{}s basically an interrupt handler. It\textquotesingle{}s composed of 2 files\+:
\begin{DoxyItemize}
\item {\itshape \hyperlink{coding__wheels_8h_source}{coding\+\_\+wheels.\+h}}
\item {\itshape coding\+\_\+wheels.\+c}
\end{DoxyItemize}

To initialize this driver, call the {\ttfamily init\+\_\+coding\+\_\+wheels()} function. As parameter, pass a {\ttfamily \hyperlink{structcoding__wheels__config__t}{coding\+\_\+wheels\+\_\+config\+\_\+t}} object. This object must contain the following information\+:
\begin{DoxyItemize}
\item initial value of each counter (right wheel and left wheel)
\item orientation of each wheel (D\+I\+R\+E\+CT or I\+N\+D\+I\+R\+E\+CT). This parameter allows the user to decide which rotation sense corresponds to a forward movement and thus to an increase of the associated counter).
\end{DoxyItemize}

{\bfseries Note}\+: It\textquotesingle{}s necessary to enable the Chibi\+OS E\+XT driver by setting {\ttfamily H\+A\+L\+\_\+\+U\+S\+E\+\_\+\+E\+XT} to {\ttfamily T\+R\+UE} in {\itshape \hyperlink{halconf_8h_source}{halconf.\+h}}

This driver then displays two counters (one for each coding wheel)\+: {\ttfamily right\+\_\+ticks} \& {\ttfamily left\+\_\+ticks}.

\subsection*{I\+MU}

This interface is handled once again by 2 files\+:
\begin{DoxyItemize}
\item {\itshape \hyperlink{orientation_8h_source}{orientation.\+h}}
\item {\itshape orientation.\+c}
\end{DoxyItemize}

It depends on the following drivers\+:
\begin{DoxyItemize}
\item bno055
\end{DoxyItemize}

\subsection*{Position \& orientation}

The goal of this component is to provide information regarding the current position and heading of the robot.

It\textquotesingle{}s composed of several files\+:
\begin{DoxyItemize}
\item {\itshape \hyperlink{position_8h_source}{position.\+h}}
\item {\itshape position.\+c}
\item {\itshape \hyperlink{settings_8h_source}{settings.\+h}}
\item {\itshape settings.\+c}
\end{DoxyItemize}

\subsection*{Control}

The goal of this component is to manage the low-\/level part of the robot movements. It will receive orders from the robot central unit and control the motors to execute them.

It\textquotesingle{}s composed of 2 files\+:
\begin{DoxyItemize}
\item {\itshape \hyperlink{control_8h_source}{control.\+h}}
\item {\itshape control.\+c}
\end{DoxyItemize}

This module defines 2 threads that run in parallel. One is in charge of computing intermediate orders based on the \char`\"{}high level\char`\"{} orders sent by the master and on the ettings defined (max acceleration, cruise speed...). The other is responsible of applying a P\+ID on the motors command based on the current order and on data read from sensors (coding wheels and I\+MU for the moment).

\subsection*{Motors}

\subsection*{Configuration}

Some configuration variables are used in order to provide the requested services. These data are stored in flash (non-\/volatile memory), so that they can be kept across reset. When booting up, the firmware loads the values from the flash and initialise the configuration varaibles with them. The I2C interface provides several registers to update these values. If you want to keep the newly updated values for subsequent execution, it\textquotesingle{}s necessary to store them in flash. To do so, simply writes any value to the {\bfseries S\+T\+O\+R\+E\+\_\+\+D\+A\+T\+A\+\_\+\+I\+N\+\_\+\+F\+L\+A\+SH} register (see the description of the communication interface to get more info on this register). 